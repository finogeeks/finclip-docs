import{_ as a,c as i,a9 as t,o as s}from"./chunks/framework.BjXht68r.js";const k=JSON.parse('{"title":"更新操作","description":"更新操作","frontmatter":{"title":"更新操作","description":"更新操作"},"headers":[],"relativePath":"docs/config/update-and-restart.md","filePath":"docs/config/update-and-restart.md"}'),o={name:"docs/config/update-and-restart.md"};function l(r,e,n,d,c,p){return s(),i("div",null,e[0]||(e[0]=[t('<h3 id="业务配置更新" tabindex="-1">业务配置更新 <a class="header-anchor" href="#业务配置更新" aria-label="Permalink to &quot;业务配置更新&quot;">​</a></h3><p>  如前面的章节所述，FinClip 私有化部署中，业务配置保存在一个配置文件中，在单节点部署中，配置文件为部署目录下的<code>fc-private.yaml</code>，在 Kubernetes环境部署中为 ConfigMap 形式的 <code>fc-private.yaml</code>， 保存在 <code>quark-cm0</code> cm 中。</p><p>  如果你需要更新配置并重新加载，只需要修改这个文件之后，重启 <code>quark</code>服务，然后重启其他响应的运维服务即可。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> edit</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> configmap</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> quark-cm0</span></span></code></pre></div><h3 id="运维配置更新" tabindex="-1">运维配置更新 <a class="header-anchor" href="#运维配置更新" aria-label="Permalink to &quot;运维配置更新&quot;">​</a></h3><p>  对于运维配置，则涉及到各种环境的差异。我们采用业界常用的运维标准进行部署，因此，修改运维相关的配置文件可以参考大部分技术资料和文章进行修改，通常是修改配置文件，然后重启服务组件即可。这些配置包括但不限于：</p><ul><li>MySQL 运维配置，我们以 docker 环境变量 + 自定义配置文件挂载的形式部署</li><li>Redis 我们以特定环境变量配置部署，配置保存在 docker compose 文件中</li><li>Minio 同上，以 Compose 配置部署</li><li>Kubernetes 相关资源，包括 Deployment、Service、ConfigMap、Secret 和 Ingress 配置等。</li></ul>',7)]))}const u=a(o,[["render",l]]);export{k as __pageData,u as default};
